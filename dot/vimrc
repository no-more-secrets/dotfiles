" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                            Options
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" This apparently fixes the 'escape time delay', a delay that
" happens after hitting the escape key (since vim is waiting for
" further characters to form a sequence). This makes that delay
" zero without affecting keys that use an escape character (such
" as arrow keys).
set timeoutlen=1000 ttimeoutlen=0

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                         Key Mappings
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" This function changes the standard `z.` so that if it is pressed twice
" within one second then the first time it is pressed it will move the
" current line to the center of the screen as usual, but the second time it
" will move the current line up to that line which is 20% of the way down
" from the top of the screen. However, a second press of z. more than one
" seconds after the first one still perform the standard behavior of moving
" to the center line.
let g:zee_dot_timer = reltime()
function! ZeeDot()
  let l:zee_delta = reltime(g:zee_dot_timer)[0]
  if l:zee_delta < 1
    let l:target = &lines/5
    let l:curr = line('.') - line('w0')
    if l:curr != l:target
      if l:curr > l:target
        call feedkeys( (l:curr-l:target) . "\<C-e>" )
      else
        call feedkeys( (l:target-l:curr) . "\<C-y>" )
      endif
    endif
  else
    call feedkeys('zz')
  endif
  let g:zee_dot_timer = reltime()
endfunction
nnoremap z. :call ZeeDot()<CR>

nnoremap <Leader>Y :set syntax=yaml<CR>

function! ReplaceWord()
    let l:w = expand( "<cword>" )
    call feedkeys( ":%s/" . l:w . "//g\<Left>\<Left>" )
endfunction
nnoremap <Leader>r :call ReplaceWord()<CR>

" Apparently this is the best way to programmatically get the
" currently selected text in visual mode.
function! GetVisualSelection()
  if mode()=="v"
      let [line_start, column_start] = getpos("v")[1:2]
      let [line_end, column_end] = getpos(".")[1:2]
  else
      let [line_start, column_start] = getpos("'<")[1:2]
      let [line_end, column_end] = getpos("'>")[1:2]
  end
  if (line2byte(line_start)+column_start) > (line2byte(line_end)+column_end)
      let [line_start, column_start, line_end, column_end] =
      \   [line_end, column_end, line_start, column_start]
  end
  let lines = getline(line_start, line_end)
  if len(lines) == 0
          return ''
  endif
  let lines[-1] = lines[-1][: column_end - 1]
  let lines[0] = lines[0][column_start - 1:]
  return join(lines, "\n")
endfunction

" Call the :Ag function with the current word-under-cursor as
" first argument.
function! AgWord()
    let l:w = expand( "<cword>" )
    call feedkeys( ':Ag ' . l:w . "\<CR>" )
endfunction

" Call the :Ag function with the currently selected text. Appears
" to work as-is even when selected text contains spaces.
function! AgWordVisual()
    let l:w = GetVisualSelection()
    call feedkeys( ':Ag ' . l:w . "\<CR>" )
endfunction

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                             netrw
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Default file manager
let g:netrw_banner=0        " no useless banner
let g:netrw_liststyle=3     " tree view
let g:netrw_browse_split=4  " open in prior window
let g:netrw_altv=2          " open splits to the right

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                  vim-lua syntax highlighting
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" NOTE: all options are off by default, but do not support
" setting to 0 for off; so to turn an option off comment it out.
let g:lua_syntax_fancynotequal = 1
" let g:lua_syntax_nofold = 1

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                            Buffers
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Put these after the plugin stuff above since it looks like some
" syntax settings can be overwridden there.
au BufNewFile,BufRead *.cc,*.cpp,*.hpp,*.h,*.inl set syntax=cpp
au BufNewFile,BufRead *.cc,*.cpp,*.hpp,*.h,*.inl set ft=cpp
au BufNewFile,BufRead *.hs                       set syntax=haskell
au BufNewFile,BufRead *.hs                       set ft=haskell
au BufNewFile,BufRead *.mkh                      set ft=make
au BufNewFile,BufRead *.fish                     set syntax=fish
au BufNewFile,BufRead *.glsl,*.vert,*.frag       set ft=glsl

au BufNewFile,BufRead *.diff set ft=diff
au BufNewFile,BufRead *.diff set syntax=diff

" :h commentstring seems to say that this is only currently used
" to 'add markers for folding.'
au FileType vim     let g:commentstring="\" %s"
au FileType sh      let g:commentstring="# %s"
au FileType python  let g:commentstring="# %s"
au FileType haskell let g:commentstring="-- %s"
au FileType cpp     let g:commentstring="// %s"
au FileType make    let g:commentstring="# %s"

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                             Themes
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Return to last edit position when opening files and make that
" line in the center of the screen.
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"z." |
     \ endif

" Prevents ~ (tildes) from appearing on post-buffer lines by
" making them the same color as the background.
au BufEnter * highlight EndOfBuffer guifg=bg
