" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                            Options
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" This apparently fixes the 'escape time delay', a delay that
" happens after hitting the escape key (since vim is waiting for
" further characters to form a sequence). This makes that delay
" zero without affecting keys that use an escape character (such
" as arrow keys).
set timeoutlen=1000 ttimeoutlen=0

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                         Key Mappings
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" This function changes the standard `z.` so that if it is pressed twice
" within one second then the first time it is pressed it will move the
" current line to the center of the screen as usual, but the second time it
" will move the current line up to that line which is 20% of the way down
" from the top of the screen. However, a second press of z. more than one
" seconds after the first one still perform the standard behavior of moving
" to the center line.
let g:zee_dot_timer = reltime()
function! ZeeDot()
  let l:zee_delta = reltime(g:zee_dot_timer)[0]
  if l:zee_delta < 1
    let l:target = &lines/5
    let l:curr = line('.') - line('w0')
    if l:curr != l:target
      if l:curr > l:target
        call feedkeys( (l:curr-l:target) . "\<C-e>" )
      else
        call feedkeys( (l:target-l:curr) . "\<C-y>" )
      endif
    endif
  else
    call feedkeys('zz')
  endif
  let g:zee_dot_timer = reltime()
endfunction
nnoremap z. :call ZeeDot()<CR>

nnoremap <Leader>Y :set syntax=yaml<CR>

let g:tools = $HOME . '/dev/tools'

function! LuaFormatAll()
  let g:lua_format_path = g:tools . '/lua-format-current/bin/lua-format'
  " For some reason the :%! command will move the cursor to the
  " top of the document, so we need to save it and restore it.
  let pos_info = getpos( '.' )
  let line = pos_info[1]
  let col = pos_info[2]
  " undojoin will prevent the undo list from getting messed up,
  " although I'm not exactly sure how it works.
  :undojoin | exec ':%!' . g:lua_format_path
  :call setpos( '.', pos_info )
endfunction

function! SmartFormatAll()
  let ext = expand( '%:e' ) " current file extension
  if ext == 'lua'
    call LuaFormatAll()
  else
    echo 'Cannot format this file type: ' . ext
  endif
endfunction

function! ReplaceWord()
    let l:w = expand( "<cword>" )
    call feedkeys( ":%s/" . l:w . "//g\<Left>\<Left>" )
endfunction
nnoremap <Leader>r :call ReplaceWord()<CR>

" Enable GDB integration.  This is an auto command because it
" seems that if we issue this anywhere in the vimrc file itself
" then the debugging interface does not have the right colors (?).
" So we use an auto-load command which likely works because it
" loads it after the colorscheme is loaded.
au BufRead *.cpp,*.c :packadd termdebug

" Key bindings for use during debugging from the source window.
nnoremap <Leader>gb :Break<CR>
nnoremap <Leader>gn :Over<CR>
nnoremap <Leader>gs :Step<CR>
nnoremap <Leader>gc :Cont<CR>
nnoremap <Leader>gx :Clear<CR>
nnoremap <Leader>ge :Evaluate<CR>
nnoremap <Leader>gr :Run<CR>

" Use a vertical split in debug mode.
let g:termdebug_wide = 1

" Apparently this is the best way to programmatically get the
" currently selected text in visual mode.
function! GetVisualSelection()
  if mode()=="v"
      let [line_start, column_start] = getpos("v")[1:2]
      let [line_end, column_end] = getpos(".")[1:2]
  else
      let [line_start, column_start] = getpos("'<")[1:2]
      let [line_end, column_end] = getpos("'>")[1:2]
  end
  if (line2byte(line_start)+column_start) > (line2byte(line_end)+column_end)
      let [line_start, column_start, line_end, column_end] =
      \   [line_end, column_end, line_start, column_start]
  end
  let lines = getline(line_start, line_end)
  if len(lines) == 0
          return ''
  endif
  let lines[-1] = lines[-1][: column_end - 1]
  let lines[0] = lines[0][column_start - 1:]
  return join(lines, "\n")
endfunction

" Call the :Ag function with the current word-under-cursor as
" first argument.
function! AgWord()
    let l:w = expand( "<cword>" )
    call feedkeys( ':Ag ' . l:w . "\<CR>" )
endfunction

" Call the :Ag function with the currently selected text. Appears
" to work as-is even when selected text contains spaces.
function! AgWordVisual()
    let l:w = GetVisualSelection()
    call feedkeys( ':Ag ' . l:w . "\<CR>" )
endfunction

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                             netrw
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Default file manager
let g:netrw_banner=0        " no useless banner
let g:netrw_liststyle=3     " tree view
let g:netrw_browse_split=4  " open in prior window
let g:netrw_altv=2          " open splits to the right

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                  vim-lua syntax highlighting
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" NOTE: all options are off by default, but do not support
" setting to 0 for off; so to turn an option off comment it out.
" let g:lua_syntax_nosymboloperator = 1
let g:lua_syntax_fancynotequal = 1
let g:lua_syntax_nofold = 1
" let g:lua_syntax_nostdlib = 1

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                            Buffers
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Put these after the plugin stuff above since it looks like some
" syntax settings can be overwridden there.
au BufNewFile,BufRead *.cc,*.cpp,*.hpp,*.h,*.inl set syntax=cpp
au BufNewFile,BufRead *.cc,*.cpp,*.hpp,*.h,*.inl set ft=cpp
au BufNewFile,BufRead *.hs                       set syntax=haskell
au BufNewFile,BufRead *.hs                       set ft=haskell
au BufNewFile,BufRead *.mkh                      set ft=make
au BufNewFile,BufRead *.fish                     set syntax=fish
au BufNewFile,BufRead *.glsl,*.vert,*.frag       set ft=glsl

" :h commentstring seems to say that this is only currently used
" to 'add markers for folding.'
au FileType vim     let g:commentstring="\" %s"
au FileType sh      let g:commentstring="# %s"
au FileType python  let g:commentstring="# %s"
au FileType haskell let g:commentstring="-- %s"
au FileType cpp     let g:commentstring="// %s"
au FileType make    let g:commentstring="# %s"

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                             Themes
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" This is so that we don't see an ugly horizontal bar when code
" is folded.
highlight Folded guibg=#262626

" Return to last edit position when opening files and make that
" line in the center of the screen.
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"z." |
     \ endif

" Prevents ~ (tildes) from appearing on post-buffer lines by
" making them the same color as the background.
au BufEnter * highlight EndOfBuffer guifg=bg

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                              Misc
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
function! ReproportionWindowSplits()
  let l:current_tabpage = tabpagenr()
  :tabdo wincmd =
  " The above command will have left us on the last tab page, so
  " restore the tab that we were on.
  exec 'normal ' . l:current_tabpage . 'gt'
endfunction

" Re-proportion window splits on all tabs when terminal is re-
" sized.
au VimResized * :call ReproportionWindowSplits()
