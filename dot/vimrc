" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                            Options
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" This apparently fixes the 'escape time delay', a delay that
" happens after hitting the escape key (since vim is waiting for
" further characters to form a sequence). This makes that delay
" zero without affecting keys that use an escape character (such
" as arrow keys).
set timeoutlen=1000 ttimeoutlen=0

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                         Key Mappings
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" This function changes the standard `z.` so that if it is pressed twice
" within one second then the first time it is pressed it will move the
" current line to the center of the screen as usual, but the second time it
" will move the current line up to that line which is 20% of the way down
" from the top of the screen. However, a second press of z. more than one
" seconds after the first one still perform the standard behavior of moving
" to the center line.
let g:zee_dot_timer = reltime()
function! ZeeDot()
  let l:zee_delta = reltime(g:zee_dot_timer)[0]
  if l:zee_delta < 1
    let l:target = &lines/5
    let l:curr = line('.') - line('w0')
    if l:curr != l:target
      if l:curr > l:target
        call feedkeys( (l:curr-l:target) . "\<C-e>" )
      else
        call feedkeys( (l:target-l:curr) . "\<C-y>" )
      endif
    endif
  else
    call feedkeys('zz')
  endif
  let g:zee_dot_timer = reltime()
endfunction
nnoremap z. :call ZeeDot()<CR>

nnoremap <Leader>Y :set syntax=yaml<CR>

function! ReplaceWord()
    let l:w = expand( "<cword>" )
    call feedkeys( ":%s/" . l:w . "//g\<Left>\<Left>" )
endfunction
nnoremap <Leader>r :call ReplaceWord()<CR>

" Apparently this is the best way to programmatically get the
" currently selected text in visual mode.
function! GetVisualSelection()
  if mode()=="v"
      let [line_start, column_start] = getpos("v")[1:2]
      let [line_end, column_end] = getpos(".")[1:2]
  else
      let [line_start, column_start] = getpos("'<")[1:2]
      let [line_end, column_end] = getpos("'>")[1:2]
  end
  if (line2byte(line_start)+column_start) > (line2byte(line_end)+column_end)
      let [line_start, column_start, line_end, column_end] =
      \   [line_end, column_end, line_start, column_start]
  end
  let lines = getline(line_start, line_end)
  if len(lines) == 0
          return ''
  endif
  let lines[-1] = lines[-1][: column_end - 1]
  let lines[0] = lines[0][column_start - 1:]
  return join(lines, "\n")
endfunction

" Call the :Ag function with the current word-under-cursor as
" first argument.
function! AgWord()
    let l:w = expand( "<cword>" )
    call feedkeys( ':Ag ' . l:w . "\<CR>" )
endfunction

" Call the :Ag function with the currently selected text. Appears
" to work as-is even when selected text contains spaces.
function! AgWordVisual()
    let l:w = GetVisualSelection()
    call feedkeys( ':Ag ' . l:w . "\<CR>" )
endfunction

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
"                             Themes
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Return to last edit position when opening files and make that
" line in the center of the screen.
autocmd BufReadPost *
     \ if line("'\"") > 0 && line("'\"") <= line("$") |
     \   exe "normal! g`\"z." |
     \ endif
